#!/usr/bin/env bash
# shellcheck shell=bash

# >>> OBB:BEGIN variant=header source=local version=local
################################################################################
# Octivi Bash Boilerplate (OBB) Header
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
################################################################################
# Unofficial Bash "Strict Mode"
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
# Define common constants regardless if they are used in the script
__my_name="$(basename "${BASH_SOURCE[0]}")"
readonly __my_name
__my_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly __my_dir
__my_path="${__my_dir}/${__my_name}"
# shellcheck disable=SC2034
readonly __my_path
__my_args="$*"
# shellcheck disable=SC2034
readonly __my_args
# Set IFS to just newline and tab
IFS=$'\n\t'
################################################################################
# <<< OBB:END

ROOT_DIR="."
FAIL=0

usage() {
  cat <<EOF
Usage:
  ${__my_name} [-h] [<repo_root>]

Arguments:
  <repo_root>  Optional path to repository root. Default: current directory.

Options:
  -h           Show this help.
EOF
}

error() {
  printf 'ERROR: %s\n' "$*" >&2
  FAIL=1
}

trim() {
  local value="$1"
  value="${value#"${value%%[![:space:]]*}"}"
  value="${value%"${value##*[![:space:]]}"}"
  printf '%s' "$value"
}

parse_args() {
  local opt
  while getopts ":h" opt; do
    case "${opt}" in
      h)
        usage
        exit 0
        ;;
      :)
        error "Option -${OPTARG} requires an argument."
        exit 2
        ;;
      \?)
        error "Unknown option: -${OPTARG}"
        exit 2
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if (($# > 1)); then
    error "Unexpected positional arguments: $*"
    exit 2
  fi

  if (($# == 1)); then
    ROOT_DIR="$1"
  fi
}

check_skill_frontmatter() {
  local skill_file="$1"

  if [[ ! -f "$skill_file" ]]; then
    error "Missing required file: $skill_file"
    return
  fi

  local status=0
  awk '
    NR == 1 {
      if ($0 != "---") exit 10
      next
    }

    !frontmatter_done && /^---$/ {
      frontmatter_done = 1
      exit
    }

    !frontmatter_done {
      if ($0 ~ /^name:[[:space:]]*[^[:space:]].*/) has_name = 1
      if ($0 ~ /^description:[[:space:]]*.+/) has_description = 1
    }

    END {
      if (!frontmatter_done) exit 11
      if (!has_name) exit 12
      if (!has_description) exit 13
    }
  ' "$skill_file" || status=$?

  case "$status" in
    0) ;;
    10) error "$skill_file must start with YAML frontmatter delimiter ---" ;;
    11) error "$skill_file is missing closing YAML frontmatter delimiter ---" ;;
    12) error "$skill_file frontmatter is missing required field: name" ;;
    13) error "$skill_file frontmatter is missing required field: description" ;;
    *) error "$skill_file frontmatter validation failed with status $status" ;;
  esac
}

check_markdown_links() {
  local file="$1"

  while IFS= read -r md_link; do
    local target
    target="$(sed -E 's/^!?\[[^]]+\]\(([^)]*)\)$/\1/' <<<"$md_link")"
    target="${target%% *}"
    target="${target#<}"
    target="${target%>}"

    [[ -z "$target" ]] && continue
    [[ "$target" == \#* ]] && continue
    [[ "$target" =~ ^https?:// ]] && continue
    [[ "$target" =~ ^mailto: ]] && continue

    local path="${target%%#*}"
    [[ -z "$path" ]] && continue
    [[ "$path" == "..." ]] && continue

    local resolved
    if [[ "$path" == /* ]]; then
      resolved=".$path"
    else
      resolved="$(dirname "$file")/$path"
    fi

    if [[ ! -e "$resolved" ]]; then
      error "Broken local link in $file: $target"
    fi
  done < <(grep -oE '!?\[[^]]+\]\([^)]+\)' "$file" || true)
}

validate_script_path() {
  local workflow_file="$1"
  local line_no="$2"
  local script_path="$3"
  local normalized_path="${script_path#./}"

  if [[ ! -f "$normalized_path" ]]; then
    error "Missing script referenced in $workflow_file:$line_no: $normalized_path"
    return
  fi

  if [[ ! -x "$normalized_path" ]]; then
    error "Script referenced in $workflow_file:$line_no is not executable: $normalized_path"
  fi
}

check_workflow_run_command() {
  local workflow_file="$1"
  local line_no="$2"
  local command="$3"

  command="$(trim "${command%%#*}")"
  [[ -z "$command" ]] && return

  local sanitized="$command"
  sanitized="${sanitized//\"/}"
  sanitized="${sanitized//\'/}"

  local match
  while IFS= read -r match; do
    local script_path
    script_path="$(trim "$match")"
    [[ -z "$script_path" ]] && continue
    validate_script_path "$workflow_file" "$line_no" "$script_path"
  done < <(grep -oE '(^|[[:space:]])(\./)?scripts/[A-Za-z0-9._/-]+' <<<"$sanitized" | sed -E 's/^[[:space:]]+//' || true)
}

check_workflow_script_runs() {
  local workflow_file="$1"
  local line_no=0
  local in_multiline_run=0
  local multiline_indent=0

  while IFS= read -r line || [[ -n "$line" ]]; do
    line_no=$((line_no + 1))
    local indent="${line%%[^ ]*}"
    local indent_len=${#indent}

    if ((in_multiline_run)); then
      if [[ "$line" =~ ^[[:space:]]*$ ]]; then
        continue
      fi

      if ((indent_len <= multiline_indent)); then
        in_multiline_run=0
      else
        check_workflow_run_command "$workflow_file" "$line_no" "$line"
        continue
      fi
    fi

    if [[ ! "$line" =~ ^[[:space:]]*(-[[:space:]]*)?run:[[:space:]]*(.*)$ ]]; then
      continue
    fi

    local command
    command="$(trim "${BASH_REMATCH[2]}")"
    command="$(trim "${command%%#*}")"

    case "$command" in
      ""|"|"|"|-"|">"|">-")
        in_multiline_run=1
        multiline_indent=$indent_len
        ;;
      *)
        check_workflow_run_command "$workflow_file" "$line_no" "$command"
        ;;
    esac
  done < "$workflow_file"
}

check_skill_mentions() {
  local doc_file="$1"
  local skill_name="$2"

  if ! grep -q "\`$skill_name\`" "$doc_file"; then
    error "$doc_file is missing skill mention: \`$skill_name\`"
  fi
}

check_routing_rule_presence() {
  local doc_file="$1"
  local skill_name="$2"

  if ! grep -qiE "(route|use).*\`?$skill_name\`?|\`?$skill_name\`?.*(route|use)" "$doc_file"; then
    error "$doc_file is missing routing guidance for: $skill_name"
  fi
}

main() {
  parse_args "$@"

  if ! cd "$ROOT_DIR"; then
    error "Cannot change directory to: $ROOT_DIR"
    exit 2
  fi

  local -a skill_dirs=()
  mapfile -t skill_dirs < <(
    find . -mindepth 1 -maxdepth 1 -type d ! -name '.*' ! -name 'scripts' -printf '%P\n' | sort
  )

  if [[ "${#skill_dirs[@]}" -eq 0 ]]; then
    error "No skill directories found at repository root."
  fi

  local skill_dir
  for skill_dir in "${skill_dirs[@]}"; do
    check_skill_frontmatter "$skill_dir/SKILL.md"
  done

  local required_doc
  for required_doc in AGENTS.md README.md; do
    if [[ -f "$required_doc" ]]; then
      for skill_dir in "${skill_dirs[@]}"; do
        check_skill_mentions "$required_doc" "$skill_dir"
      done
    fi
  done

  local routing_skill
  for routing_skill in common-changelog git-commits git-trunk-based-workflow; do
    if [[ ! -d "$routing_skill" ]]; then
      continue
    fi

    if [[ -f AGENTS.md ]]; then
      check_routing_rule_presence "AGENTS.md" "$routing_skill"
    fi
    if [[ -f README.md ]]; then
      check_routing_rule_presence "README.md" "$routing_skill"
    fi
  done

  local -a doc_files=()
  local root_doc
  for root_doc in README.md AGENTS.md CONTRIBUTING.md; do
    if [[ -f "$root_doc" ]]; then
      doc_files+=("$root_doc")
    fi
  done

  for skill_dir in "${skill_dirs[@]}"; do
    if [[ -f "$skill_dir/README.md" ]]; then
      doc_files+=("$skill_dir/README.md")
    fi
    doc_files+=("$skill_dir/SKILL.md")
    if [[ -d "$skill_dir/references" ]]; then
      local ref_file
      while IFS= read -r ref_file; do
        doc_files+=("$ref_file")
      done < <(find "$skill_dir/references" -maxdepth 1 -type f -name '*.md' | sort)
    fi
  done

  local doc_file
  for doc_file in "${doc_files[@]}"; do
    check_markdown_links "$doc_file"
  done

  if [[ -d ".github/workflows" ]]; then
    local -a workflow_files=()
    while IFS= read -r workflow_file; do
      workflow_files+=("$workflow_file")
    done < <(find .github/workflows -type f \( -name '*.yml' -o -name '*.yaml' \) | sort)

    local workflow_file
    for workflow_file in "${workflow_files[@]}"; do
      check_workflow_script_runs "$workflow_file"
    done
  fi

  if ((FAIL != 0)); then
    printf 'Validation failed.\n' >&2
    exit 1
  fi

  printf 'Validation succeeded.\n'
}

main "$@"
